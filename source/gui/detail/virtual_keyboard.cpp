/**
*	Virtual Keyboard Implementations
*	Nana C++ Library(http://www.nanapro.org)
*	Copyright(C) 2003-2024 Jinhao(cnjinhao@hotmail.com)
*
*	Distributed under the Boost Software License, Version 1.0.
*	(See accompanying file LICENSE_1_0.txt or copy at
*	http://www.boost.org/LICENSE_1_0.txt)
*
*	@file nana/gui/detail/keyboard.cpp
*/

#include <map>
#include <algorithm>  //std::clamp

#include <nana/gui/widgets/form.hpp>
#include <nana/gui/widgets/panel.hpp>
#include <nana/gui/widgets/combox.hpp>
#include <nana/gui/widgets/textbox.hpp>
#include <nana/gui/element.hpp>
#include <nana/gui/compact.hpp>
#include <nana/gui/drawing.hpp>
#include <nana/gui/screen.hpp>
#include <nana/gui/detail/virtual_keyboard.hpp>
#include <nana/gui/programming_interface.hpp>
#include "keyboard_im.hpp"

namespace nana::detail
{
	namespace keyboards
	{
		static const std::uint16_t image_backspace_120x120[] = {
			0x987, 0x0, 0x1, 0x42, 0x50, 0xff, 0x26, 0x0, 0x1, 0x42, 0x51, 0xff, 0x25, 0x0, 0x1, 0x42, 0x52, 0xff, 0x24, 0x0, 0x1, 0x42, 0x53, 0xff, 0x23, 0x0, 0x1, 0x42, 0x54, 0xff, 0x22, 0x0, 0x1, 0x42, 0x55, 0xff, 0x21, 0x0, 0x1, 0x42, 0x56, 0xff, 0x20, 0x0, 0x1, 0x42, 0x57, 0xff, 0x1f, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x45, 0x0, 0x8, 0xff, 0x1e, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x46, 0x0, 0x8, 0xff, 0x1d, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x47, 0x0, 0x8, 0xff, 0x1c, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x48, 0x0, 0x8, 0xff, 0x1b, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x49, 0x0, 0x8, 0xff, 0x1a, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x4a, 0x0, 0x8, 0xff, 0x19, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x4b, 0x0, 0x8, 0xff, 0x18, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x4c, 0x0, 0x8, 0xff, 0x17, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x1a, 0x0, 0x1, 0xf5, 0x24, 0x0, 0x1, 0xf5, 0xd, 0x0, 0x8, 0xff, 0x16, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x1a, 0x0, 0x1, 0xf5, 0x2, 0xff, 0x22, 0x0, 0x2, 0xff, 0x1, 0xf5, 0xc, 0x0, 0x8, 0xff, 0x15, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x1a, 0x0, 0x1, 0xf5, 0x4, 0xff, 0x20, 0x0, 0x4, 0xff, 0x1, 0xf5, 0xb, 0x0, 0x8, 0xff, 0x14, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x1a, 0x0, 0x1, 0xf5, 0x6, 0xff, 0x1e, 0x0, 0x6, 0xff, 0x1, 0xf5, 0xa, 0x0, 0x8, 0xff, 0x13, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x1a, 0x0, 0x1, 0xf5, 0x8, 0xff, 0x1c, 0x0, 0x8, 0xff, 0x1, 0xf5, 0x9, 0x0, 0x8, 0xff, 0x12, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x1a, 0x0, 0x1, 0xf5, 0xa, 0xff, 0x1a, 0x0, 0xa, 0xff, 0x1, 0xf5, 0x8, 0x0, 0x8, 0xff, 0x11, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x1c, 0x0, 0xb, 0xff, 0x18, 0x0, 0xb, 0xff, 0x9, 0x0, 0x8, 0xff, 0x10, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x1e, 0x0, 0xb, 0xff, 0x16, 0x0, 0xb, 0xff, 0xa, 0x0, 0x8, 0xff, 0xf, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x20, 0x0, 0xb, 0xff, 0x14, 0x0, 0xb, 0xff, 0xb, 0x0, 0x8, 0xff, 0xe, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x22, 0x0, 0xb, 0xff, 0x12, 0x0, 0xb, 0xff, 0xc, 0x0, 0x8, 0xff, 0xd, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x24, 0x0, 0xb, 0xff, 0x10, 0x0, 0xb, 0xff, 0xd, 0x0, 0x8, 0xff, 0xc, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x26, 0x0, 0xb, 0xff, 0xe, 0x0, 0xb, 0xff, 0xe, 0x0, 0x8, 0xff, 0xb, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x28, 0x0, 0xb, 0xff, 0xc, 0x0, 0xb, 0xff, 0xf, 0x0, 0x8, 0xff, 0xa, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x2a, 0x0, 0xb, 0xff, 0xa, 0x0, 0xb, 0xff, 0x10, 0x0, 0x8, 0xff, 0x9, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x2c, 0x0, 0xb, 0xff, 0x8, 0x0, 0xb, 0xff, 0x11, 0x0, 0x8, 0xff, 0x8, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x2e, 0x0, 0xb, 0xff, 0x6, 0x0, 0xb, 0xff, 0x12, 0x0, 0x8, 0xff, 0x7, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x30, 0x0, 0xb, 0xff, 0x4, 0x0, 0xb, 0xff, 0x13, 0x0, 0x8, 0xff, 0x6, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x32, 0x0, 0xb, 0xff, 0x2, 0x0, 0xb, 0xff, 0x14, 0x0, 0x8, 0xff, 0x5, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x34, 0x0, 0x16, 0xff, 0x15, 0x0, 0x8, 0xff, 0x4, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x36, 0x0, 0x14, 0xff, 0x16, 0x0, 0x8, 0xff, 0x3, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x38, 0x0, 0x12, 0xff, 0x17, 0x0, 0x8, 0xff, 0x2, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x3a, 0x0, 0x10, 0xff, 0x18, 0x0, 0x8, 0xff, 0x1, 0x0, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x3c, 0x0, 0xe, 0xff, 0x19, 0x0, 0x8, 0xff, 0x1, 0x42, 0xa, 0xff, 0x1, 0xdc, 0x3e, 0x0, 0xc, 0xff, 0x1a, 0x0, 0x8, 0xff, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x3e, 0x0, 0xc, 0xff, 0x1a, 0x0, 0x8, 0xff, 0x1, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x3c, 0x0, 0xe, 0xff, 0x19, 0x0, 0x8, 0xff, 0x2, 0x0, 0x1, 0x3e, 0xa, 0xff, 0x1, 0xe0, 0x3a, 0x0, 0x10, 0xff, 0x18, 0x0, 0x8, 0xff, 0x3, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x38, 0x0, 0x12, 0xff, 0x17, 0x0, 0x8, 0xff, 0x4, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x36, 0x0, 0x14, 0xff, 0x16, 0x0, 0x8, 0xff, 0x5, 0x0, 0x1, 0x3d, 0xa, 0xff, 0x1, 0xe0, 0x34, 0x0, 0x16, 0xff, 0x15, 0x0, 0x8, 0xff, 0x6, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x32, 0x0, 0xb, 0xff, 0x2, 0x0, 0xb, 0xff, 0x14, 0x0, 0x8, 0xff, 0x7, 0x0, 0x1, 0x3e, 0xa, 0xff, 0x1, 0xe0, 0x30, 0x0, 0xb, 0xff, 0x4, 0x0, 0xb, 0xff, 0x13, 0x0, 0x8, 0xff, 0x8, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x2e, 0x0, 0xb, 0xff, 0x6, 0x0, 0xb, 0xff, 0x12, 0x0, 0x8, 0xff, 0x9, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x2c, 0x0, 0xb, 0xff, 0x8, 0x0, 0xb, 0xff, 0x11, 0x0, 0x8, 0xff, 0xa, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x2a, 0x0, 0xb, 0xff, 0xa, 0x0, 0xb, 0xff, 0x10, 0x0, 0x8, 0xff, 0xb, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x28, 0x0, 0xb, 0xff, 0xc, 0x0, 0xb, 0xff, 0xf, 0x0, 0x8, 0xff, 0xc, 0x0, 0x1, 0x3e, 0xa, 0xff, 0x1, 0xe0, 0x26, 0x0, 0xb, 0xff, 0xe, 0x0, 0xb, 0xff, 0xe, 0x0, 0x8, 0xff, 0xd, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x24, 0x0, 0xb, 0xff, 0x10, 0x0, 0xb, 0xff, 0xd, 0x0, 0x8, 0xff, 0xe, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x22, 0x0, 0xb, 0xff, 0x12, 0x0, 0xb, 0xff, 0xc, 0x0, 0x8, 0xff, 0xf, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x20, 0x0, 0xb, 0xff, 0x14, 0x0, 0xb, 0xff, 0xb, 0x0, 0x8, 0xff, 0x10, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x1e, 0x0, 0xb, 0xff, 0x16, 0x0, 0xb, 0xff, 0xa, 0x0, 0x8, 0xff, 0x11, 0x0, 0x1, 0x3e, 0xa, 0xff, 0x1, 0xe0, 0x1c, 0x0, 0xb, 0xff, 0x18, 0x0, 0xb, 0xff, 0x9, 0x0, 0x8, 0xff, 0x12, 0x0, 0x1, 0x3d, 0xa, 0xff, 0x1, 0xdc, 0x1a, 0x0, 0x1, 0xf3, 0xa, 0xff, 0x1a, 0x0, 0xa, 0xff, 0x1, 0xf3, 0x8, 0x0, 0x8, 0xff, 0x13, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x1a, 0x0, 0x1, 0xf3, 0x8, 0xff, 0x1c, 0x0, 0x8, 0xff, 0x1, 0xf3, 0x9, 0x0, 0x8, 0xff, 0x14, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x1a, 0x0, 0x1, 0xf3, 0x6, 0xff, 0x1e, 0x0, 0x6, 0xff, 0x1, 0xf3, 0xa, 0x0, 0x8, 0xff, 0x15, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x1a, 0x0, 0x1, 0xf3, 0x4, 0xff, 0x20, 0x0, 0x4, 0xff, 0x1, 0xf3, 0xb, 0x0, 0x8, 0xff, 0x16, 0x0, 0x1, 0x3e, 0xa, 0xff, 0x1, 0xe0, 0x1a, 0x0, 0x1, 0xf3, 0x2, 0xff, 0x22, 0x0, 0x2, 0xff, 0x1, 0xf3, 0xc, 0x0, 0x8, 0xff, 0x17, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x1a, 0x0, 0x1, 0xf3, 0x24, 0x0, 0x1, 0xf3, 0xd, 0x0, 0x8, 0xff, 0x18, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x4c, 0x0, 0x8, 0xff, 0x19, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x4b, 0x0, 0x8, 0xff, 0x1a, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x4a, 0x0, 0x8, 0xff, 0x1b, 0x0, 0x1, 0x3e, 0xa, 0xff, 0x1, 0xe0, 0x49, 0x0, 0x8, 0xff, 0x1c, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x48, 0x0, 0x8, 0xff, 0x1d, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x47, 0x0, 0x8, 0xff, 0x1e, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x46, 0x0, 0x8, 0xff, 0x1f, 0x0, 0x1, 0x3b, 0xa, 0xff, 0x1, 0xe0, 0x45, 0x0, 0x8, 0xff, 0x20, 0x0, 0x1, 0x3e, 0x57, 0xff, 0x21, 0x0, 0x1, 0x3b, 0x56, 0xff, 0x22, 0x0, 0x1, 0x3b, 0x55, 0xff, 0x23, 0x0, 0x1, 0x3b, 0x54, 0xff, 0x24, 0x0, 0x1, 0x3b, 0x53, 0xff, 0x25, 0x0, 0x1, 0x3e, 0x52, 0xff, 0x26, 0x0, 0x1, 0x3b, 0x51, 0xff, 0x27, 0x0, 0x1, 0x3b, 0x50, 0xff, 0x960, 0x0
		};

		static const std::uint16_t image_earth_120x120[] = {
			0x38, 0x0, 0x1, 0x13, 0x1, 0x61, 0x1, 0x8c, 0x1, 0xbd, 0x1, 0xfb, 0x1, 0xc1, 0x1, 0x8f, 0x1, 0x64, 0x1, 0x17, 0x68, 0x0, 0x1, 0x33, 0x15, 0xff, 0x1, 0x40, 0x5d, 0x0, 0x1, 0x71, 0x1d, 0xff, 0x1, 0x3c, 0x56, 0x0, 0x1, 0xd8, 0x23, 0xff, 0x1, 0xf1, 0x50, 0x0, 0x2b, 0xff, 0x1, 0x3, 0x49, 0x0, 0x1, 0x10, 0x2f, 0xff, 0x1, 0x27, 0x45, 0x0, 0x1, 0x3d, 0x33, 0xff, 0x1, 0x6d, 0x41, 0x0, 0x1, 0x1, 0x37, 0xff, 0x1, 0xa, 0x3d, 0x0, 0x1, 0x5d, 0x3b, 0xff, 0x1, 0x9, 0x3a, 0x0, 0x3f, 0xff, 0x37, 0x0, 0x1, 0x57, 0x14, 0xff, 0x1, 0xd4, 0x2, 0x0, 0x13, 0xff, 0x2, 0x0, 0x1, 0xb5, 0x14, 0xff, 0x1, 0x8a, 0x34, 0x0, 0x1, 0xf7, 0x12, 0xff, 0x1, 0x1b, 0x4, 0x0, 0x1, 0x5f, 0x13, 0xff, 0x1, 0xa9, 0x4, 0x0, 0x1, 0x2c, 0x13, 0xff, 0x31, 0x0, 0x1, 0x3e, 0x11, 0xff, 0x8, 0x0, 0xa, 0xff, 0x1, 0x0, 0xa, 0xff, 0x8, 0x0, 0x11, 0xff, 0x1, 0x63, 0x2e, 0x0, 0x10, 0xff, 0x1, 0xcd, 0x9, 0x0, 0xa, 0xff, 0x1, 0x31, 0x1, 0x0, 0x1, 0xf, 0xa, 0xff, 0x9, 0x0, 0x1, 0xae, 0x10, 0xff, 0x2c, 0x0, 0x10, 0xff, 0xb, 0x0, 0xa, 0xff, 0x3, 0x0, 0xa, 0xff, 0xb, 0x0, 0x10, 0xff, 0x2a, 0x0, 0xe, 0xff, 0x1, 0x60, 0xc, 0x0, 0xa, 0xff, 0x5, 0x0, 0xa, 0xff, 0xc, 0x0, 0x1, 0x49, 0xe, 0xff, 0x28, 0x0, 0xe, 0xff, 0xd, 0x0, 0x1, 0xbc, 0x9, 0xff, 0x7, 0x0, 0x9, 0xff, 0x1, 0xf1, 0xd, 0x0, 0xe, 0xff, 0x26, 0x0, 0xd, 0xff, 0x1, 0x48, 0xe, 0x0, 0xa, 0xff, 0x7, 0x0, 0xa, 0xff, 0xe, 0x0, 0x1, 0x2e, 0xd, 0xff, 0x24, 0x0, 0xd, 0xff, 0xf, 0x0, 0xa, 0xff, 0x1, 0x2, 0x8, 0x0, 0xa, 0xff, 0xf, 0x0, 0xd, 0xff, 0x22, 0x0, 0xc, 0xff, 0x1, 0x3e, 0x10, 0x0, 0x9, 0xff, 0x1, 0xfb, 0x9, 0x0, 0x1, 0xcf, 0x9, 0xff, 0x10, 0x0, 0x1, 0x24, 0xc, 0xff, 0x1, 0x2, 0x1f, 0x0, 0xc, 0xff, 0x11, 0x0, 0xa, 0xff, 0xb, 0x0, 0xa, 0xff, 0x11, 0x0, 0xc, 0xff, 0x1e, 0x0, 0xc, 0xff, 0x12, 0x0, 0x9, 0xff, 0x1, 0x58, 0xb, 0x0, 0x1, 0x1e, 0x9, 0xff, 0x12, 0x0, 0xc, 0xff, 0x1c, 0x0, 0x1, 0xf9, 0xb, 0xff, 0x12, 0x0, 0x1, 0xde, 0x9, 0xff, 0xd, 0x0, 0xa, 0xff, 0x12, 0x0, 0xc, 0xff, 0x1a, 0x0, 0x1, 0xfd, 0xb, 0xff, 0x13, 0x0, 0x9, 0xff, 0xf, 0x0, 0x9, 0xff, 0x13, 0x0, 0xc, 0xff, 0x18, 0x0, 0x1, 0x20, 0xb, 0xff, 0x13, 0x0, 0xa, 0xff, 0xf, 0x0, 0xa, 0xff, 0x13, 0x0, 0xb, 0xff, 0x1, 0x41, 0x17, 0x0, 0xb, 0xff, 0x14, 0x0, 0x9, 0xff, 0x1, 0x8f, 0xf, 0x0, 0x1, 0x3f, 0x9, 0xff, 0x14, 0x0, 0xb, 0xff, 0x16, 0x0, 0x1, 0xf3, 0xa, 0xff, 0x14, 0x0, 0x1, 0xcf, 0x9, 0xff, 0x11, 0x0, 0x9, 0xff, 0x1, 0xfb, 0x14, 0x0, 0xa, 0xff, 0x1, 0xf3, 0x14, 0x0, 0x1, 0x2d, 0xc, 0xff, 0x13, 0x0, 0x9, 0xff, 0x1, 0x12, 0x11, 0x0, 0x1, 0x1, 0x9, 0xff, 0x13, 0x0, 0xc, 0xff, 0x1, 0x2d, 0x13, 0x0, 0xf, 0xff, 0x11, 0x0, 0x9, 0xff, 0x13, 0x0, 0x9, 0xff, 0x11, 0x0, 0xf, 0xff, 0x12, 0x0, 0x12, 0xff, 0x1, 0x2c, 0xd, 0x0, 0x9, 0xff, 0x1, 0x6c, 0x13, 0x0, 0x1, 0x2a, 0x9, 0xff, 0xd, 0x0, 0x1, 0x23, 0x12, 0xff, 0x10, 0x0, 0x1, 0x57, 0x15, 0xff, 0x1, 0xa3, 0xa, 0x0, 0x9, 0xff, 0x15, 0x0, 0x9, 0xff, 0xa, 0x0, 0x1, 0xf7, 0x15, 0xff, 0x1, 0x57, 0xf, 0x0, 0x1a, 0xff, 0x6, 0x0, 0x1, 0xae, 0x8, 0xff, 0x1, 0xb0, 0x15, 0x0, 0x1, 0x5e, 0x8, 0xff, 0x1, 0xef, 0x6, 0x0, 0x1a, 0xff, 0xf, 0x0, 0x1e, 0xff, 0x1, 0x5, 0x1, 0x0, 0x9, 0xff, 0x17, 0x0, 0x9, 0xff, 0x1, 0x0, 0x1, 0x4, 0x1e, 0xff, 0xe, 0x0, 0x2a, 0xff, 0x17, 0x0, 0x2a, 0xff, 0xc, 0x0, 0x1, 0x68, 0x9, 0xff, 0x2, 0x0, 0x23, 0xff, 0x1, 0x95, 0x1, 0x33, 0x1, 0x1c, 0x1, 0xc, 0x1, 0x1, 0x5, 0x0, 0x1, 0x1, 0x1, 0xb, 0x1, 0x1b, 0x1, 0x31, 0x1, 0x8c, 0x23, 0xff, 0x2, 0x0, 0x9, 0xff, 0x1, 0x68, 0xb, 0x0, 0x9, 0xff, 0x1, 0x5b, 0x4, 0x0, 0x51, 0xff, 0x1, 0x1, 0x3, 0x0, 0xa, 0xff, 0xa, 0x0, 0x1, 0xe, 0x9, 0xff, 0x7, 0x0, 0x4d, 0xff, 0x7, 0x0, 0x9, 0xff, 0x1, 0xe, 0x9, 0x0, 0xa, 0xff, 0x9, 0x0, 0x1, 0x71, 0x47, 0xff, 0x1, 0x86, 0x9, 0x0, 0x1, 0xfb, 0x9, 0xff, 0x8, 0x0, 0x1, 0x4, 0x9, 0xff, 0xd, 0x0, 0x1, 0x19, 0x41, 0xff, 0x1, 0x21, 0xd, 0x0, 0x9, 0xff, 0x1, 0x4, 0x7, 0x0, 0x9, 0xff, 0x1, 0xe5, 0x10, 0x0, 0x1, 0xf, 0x3b, 0xff, 0x11, 0x0, 0x1, 0xa8, 0x9, 0xff, 0x7, 0x0, 0x9, 0xff, 0x15, 0x0, 0x1, 0x42, 0x33, 0xff, 0x1, 0x4b, 0x15, 0x0, 0x9, 0xff, 0x7, 0x0, 0x9, 0xff, 0x18, 0x0, 0x1, 0xf1, 0x2e, 0xff, 0x18, 0x0, 0x9, 0xff, 0x6, 0x0, 0x9, 0xff, 0x19, 0x0, 0x9, 0xff, 0x1, 0x31, 0x1, 0xa0, 0x19, 0xff, 0x1, 0x89, 0x1, 0x23, 0x9, 0xff, 0x19, 0x0, 0x9, 0xff, 0x5, 0x0, 0x9, 0xff, 0x19, 0x0, 0x8, 0xff, 0x1, 0x57, 0x1d, 0x0, 0x9, 0xff, 0x19, 0x0, 0x9, 0xff, 0x5, 0x0, 0x9, 0xff, 0x19, 0x0, 0x8, 0xff, 0x1e, 0x0, 0x1, 0x1b, 0x8, 0xff, 0x1, 0x9, 0x18, 0x0, 0x9, 0xff, 0x4, 0x0, 0x1, 0xa0, 0x8, 0xff, 0x1, 0x10, 0x18, 0x0, 0x1, 0xfb, 0x8, 0xff, 0x1f, 0x0, 0x9, 0xff, 0x18, 0x0, 0x1, 0x2, 0x8, 0xff, 0x1, 0x96, 0x3, 0x0, 0x9, 0xff, 0x19, 0x0, 0x9, 0xff, 0x1f, 0x0, 0x9, 0xff, 0x19, 0x0, 0x9, 0xff, 0x3, 0x0, 0x9, 0xff, 0x19, 0x0, 0x9, 0xff, 0x1f, 0x0, 0x9, 0xff, 0x19, 0x0, 0x9, 0xff, 0x3, 0x0, 0x8, 0xff, 0x1, 0xed, 0x19, 0x0, 0x8, 0xff, 0x1, 0xd6, 0x1f, 0x0, 0x1, 0x79, 0x8, 0xff, 0x19, 0x0, 0x1, 0xa6, 0x8, 0xff, 0x2, 0x0, 0x1, 0x47, 0x8, 0xff, 0x1a, 0x0, 0x8, 0xff, 0x21, 0x0, 0x8, 0xff, 0x1, 0x1, 0x19, 0x0, 0x8, 0xff, 0x1, 0x44, 0x1, 0x0, 0x9, 0xff, 0x19, 0x0, 0x1, 0x32, 0x8, 0xff, 0x21, 0x0, 0x8, 0xff, 0x1, 0x63, 0x19, 0x0, 0x9, 0xff, 0x1, 0x0, 0x9, 0xff, 0x19, 0x0, 0x1, 0xf1, 0x8, 0xff, 0x21, 0x0, 0x9, 0xff, 0x19, 0x0, 0x9, 0xff, 0x1, 0x0, 0x9, 0xff, 0x19, 0x0, 0x9, 0xff, 0x21, 0x0, 0x9, 0xff, 0x19, 0x0, 0x9, 0xff, 0x1, 0x0, 0x8, 0xff, 0x1, 0x9e, 0x19, 0x0, 0x9, 0xff, 0x21, 0x0, 0x9, 0xff, 0x19, 0x0, 0x1, 0x5b, 0x8, 0xff, 0x1, 0x0, 0x8, 0xff, 0x1, 0x1d, 0x19, 0x0, 0x9, 0xff, 0x21, 0x0, 0x9, 0xff, 0x19, 0x0, 0x1, 0x5, 0x8, 0xff, 0x1, 0x0, 0x8, 0xff, 0x1a, 0x0, 0x8, 0xff, 0x1, 0xd1, 0x21, 0x0, 0x1, 0x81, 0x8, 0xff, 0x1a, 0x0, 0x8, 0xff, 0x1, 0x1a, 0x77, 0xff, 0x1, 0x41, 0x77, 0xff, 0x1, 0x6d, 0x77, 0xff, 0x1, 0xa4, 0x77, 0xff, 0x1, 0xe7, 0x77, 0xff, 0x1, 0xa4, 0x77, 0xff, 0x1, 0x6d, 0x77, 0xff, 0x1, 0x41, 0x77, 0xff, 0x1, 0x1a, 0x77, 0xff, 0x1, 0x0, 0x8, 0xff, 0x1a, 0x0, 0x8, 0xff, 0x1, 0xcf, 0x21, 0x0, 0x1, 0x83, 0x8, 0xff, 0x1a, 0x0, 0x8, 0xff, 0x1, 0x0, 0x8, 0xff, 0x1, 0x1d, 0x19, 0x0, 0x9, 0xff, 0x21, 0x0, 0x9, 0xff, 0x19, 0x0, 0x1, 0x5, 0x8, 0xff, 0x1, 0x0, 0x8, 0xff, 0x1, 0x9e, 0x19, 0x0, 0x9, 0xff, 0x21, 0x0, 0x9, 0xff, 0x19, 0x0, 0x1, 0x5b, 0x8, 0xff, 0x1, 0x0, 0x9, 0xff, 0x19, 0x0, 0x9, 0xff, 0x21, 0x0, 0x9, 0xff, 0x19, 0x0, 0x9, 0xff, 0x1, 0x0, 0x9, 0xff, 0x19, 0x0, 0x1, 0xf1, 0x8, 0xff, 0x21, 0x0, 0x9, 0xff, 0x19, 0x0, 0x9, 0xff, 0x1, 0x0, 0x9, 0xff, 0x19, 0x0, 0x1, 0x32, 0x8, 0xff, 0x21, 0x0, 0x8, 0xff, 0x1, 0x66, 0x19, 0x0, 0x9, 0xff, 0x1, 0x0, 0x1, 0x47, 0x8, 0xff, 0x1a, 0x0, 0x8, 0xff, 0x21, 0x0, 0x8, 0xff, 0x1, 0x2, 0x19, 0x0, 0x8, 0xff, 0x1, 0x44, 0x2, 0x0, 0x8, 0xff, 0x1, 0xed, 0x19, 0x0, 0x8, 0xff, 0x1, 0xc8, 0x1f, 0x0, 0x1, 0x87, 0x8, 0xff, 0x19, 0x0, 0x1, 0xa6, 0x8, 0xff, 0x3, 0x0, 0x9, 0xff, 0x19, 0x0, 0x9, 0xff, 0x1f, 0x0, 0x9, 0xff, 0x19, 0x0, 0x9, 0xff, 0x3, 0x0, 0x9, 0xff, 0x19, 0x0, 0x9, 0xff, 0x1f, 0x0, 0x9, 0xff, 0x19, 0x0, 0x9, 0xff, 0x3, 0x0, 0x1, 0x43, 0x8, 0xff, 0x1, 0x4c, 0x18, 0x0, 0x1, 0xab, 0x8, 0xff, 0x1f, 0x0, 0x8, 0xff, 0x1, 0xfb, 0x18, 0x0, 0x1, 0x25, 0x8, 0xff, 0x1, 0x3e, 0x4, 0x0, 0x9, 0xff, 0x19, 0x0, 0x8, 0xff, 0x1e, 0x0, 0x1, 0x28, 0x8, 0xff, 0x1, 0xc, 0x18, 0x0, 0x9, 0xff, 0x5, 0x0, 0x9, 0xff, 0x19, 0x0, 0x8, 0xff, 0x1, 0x47, 0x1d, 0x0, 0x9, 0xff, 0x19, 0x0, 0x9, 0xff, 0x5, 0x0, 0x9, 0xff, 0x19, 0x0, 0x9, 0xff, 0x1, 0x32, 0x1, 0xa1, 0x19, 0xff, 0x1, 0xa6, 0x1, 0x34, 0x9, 0xff, 0x19, 0x0, 0x9, 0xff, 0x6, 0x0, 0x9, 0xff, 0x18, 0x0, 0x1, 0xe9, 0x2e, 0xff, 0x18, 0x0, 0x9, 0xff, 0x7, 0x0, 0x9, 0xff, 0x15, 0x0, 0x1, 0x41, 0x33, 0xff, 0x1, 0x4c, 0x15, 0x0, 0x9, 0xff, 0x7, 0x0, 0x9, 0xff, 0x1, 0xe5, 0x10, 0x0, 0x1, 0xf, 0x3b, 0xff, 0x11, 0x0, 0x1, 0xa8, 0x9, 0xff, 0x7, 0x0, 0x1, 0x4, 0x9, 0xff, 0xd, 0x0, 0x1, 0x18, 0x41, 0xff, 0x1, 0x22, 0xd, 0x0, 0x9, 0xff, 0x1, 0x4, 0x8, 0x0, 0xa, 0xff, 0x9, 0x0, 0x1, 0x6d, 0x47, 0xff, 0x1, 0x81, 0x9, 0x0, 0x1, 0xfb, 0x9, 0xff, 0x9, 0x0, 0x1, 0xe, 0x9, 0xff, 0x7, 0x0, 0x4d, 0xff, 0x7, 0x0, 0x9, 0xff, 0x1, 0xe, 0xa, 0x0, 0x9, 0xff, 0x1, 0x5b, 0x4, 0x0, 0x51, 0xff, 0x1, 0x1, 0x3, 0x0, 0xa, 0xff, 0xb, 0x0, 0x1, 0x68, 0x9, 0xff, 0x2, 0x0, 0x23, 0xff, 0x1, 0x89, 0x1, 0x2c, 0x1, 0x16, 0x1, 0x9, 0x7, 0x0, 0x1, 0x9, 0x1, 0x16, 0x1, 0x2a, 0x1, 0x83, 0x23, 0xff, 0x2, 0x0, 0x9, 0xff, 0x1, 0x68, 0xc, 0x0, 0x2a, 0xff, 0x17, 0x0, 0x2a, 0xff, 0xe, 0x0, 0x1e, 0xff, 0x1, 0x6, 0x1, 0x0, 0x9, 0xff, 0x17, 0x0, 0x9, 0xff, 0x1, 0x0, 0x1, 0x4, 0x1e, 0xff, 0xf, 0x0, 0x1a, 0xff, 0x6, 0x0, 0x1, 0xb5, 0x8, 0xff, 0x1, 0xa1, 0x15, 0x0, 0x1, 0x71, 0x8, 0xff, 0x1, 0xe7, 0x6, 0x0, 0x1a, 0xff, 0xf, 0x0, 0x1, 0x1, 0x15, 0xff, 0xb, 0x0, 0x9, 0xff, 0x15, 0x0, 0x9, 0xff, 0xa, 0x0, 0x1, 0x2, 0x15, 0xff, 0x1, 0x1, 0x10, 0x0, 0x12, 0xff, 0x1, 0x30, 0xd, 0x0, 0x9, 0xff, 0x1, 0x5a, 0x13, 0x0, 0x1, 0x38, 0x9, 0xff, 0xd, 0x0, 0x1, 0x25, 0x12, 0xff, 0x12, 0x0, 0xf, 0xff, 0x11, 0x0, 0x9, 0xff, 0x13, 0x0, 0x9, 0xff, 0x11, 0x0, 0xf, 0xff, 0x13, 0x0, 0x1, 0x2d, 0xc, 0xff, 0x13, 0x0, 0x9, 0xff, 0x1, 0xb, 0x11, 0x0, 0x1, 0x3, 0x9, 0xff, 0x13, 0x0, 0xc, 0xff, 0x1, 0x2d, 0x14, 0x0, 0x1, 0xf3, 0xa, 0xff, 0x14, 0x0, 0x1, 0xd8, 0x9, 0xff, 0x11, 0x0, 0x9, 0xff, 0x1, 0xf7, 0x14, 0x0, 0xa, 0xff, 0x1, 0xf3, 0x16, 0x0, 0xb, 0xff, 0x14, 0x0, 0x9, 0xff, 0x1, 0x78, 0xf, 0x0, 0x1, 0x50, 0x9, 0xff, 0x14, 0x0, 0xb, 0xff, 0x17, 0x0, 0x1, 0x1f, 0xb, 0xff, 0x13, 0x0, 0xa, 0xff, 0xf, 0x0, 0xa, 0xff, 0x13, 0x0, 0xb, 0xff, 0x1, 0x1b, 0x18, 0x0, 0x1, 0xfb, 0xb, 0xff, 0x13, 0x0, 0x9, 0xff, 0xf, 0x0, 0x9, 0xff, 0x13, 0x0, 0xb, 0xff, 0x1, 0xfb, 0x1a, 0x0, 0x1, 0xf7, 0xb, 0xff, 0x12, 0x0, 0x1, 0xe9, 0x9, 0xff, 0xd, 0x0, 0x9, 0xff, 0x1, 0xfd, 0x12, 0x0, 0xb, 0xff, 0x1, 0xf7, 0x1c, 0x0, 0xc, 0xff, 0x12, 0x0, 0x9, 0xff, 0x1, 0x48, 0xb, 0x0, 0x1, 0x28, 0x9, 0xff, 0x12, 0x0, 0xc, 0xff, 0x1e, 0x0, 0xc, 0xff, 0x11, 0x0, 0xa, 0xff, 0xb, 0x0, 0xa, 0xff, 0x11, 0x0, 0xc, 0xff, 0x20, 0x0, 0xc, 0xff, 0x1, 0x40, 0x10, 0x0, 0x9, 0xff, 0x1, 0xf7, 0x9, 0x0, 0x1, 0xdc, 0x9, 0xff, 0x10, 0x0, 0x1, 0x21, 0xc, 0xff, 0x22, 0x0, 0xd, 0xff, 0xf, 0x0, 0xa, 0xff, 0x1, 0x1, 0x8, 0x0, 0xa, 0xff, 0xf, 0x0, 0xd, 0xff, 0x24, 0x0, 0xd, 0xff, 0x1, 0x4a, 0xe, 0x0, 0xa, 0xff, 0x7, 0x0, 0xa, 0xff, 0xe, 0x0, 0x1, 0x2b, 0xd, 0xff, 0x26, 0x0, 0xe, 0xff, 0xd, 0x0, 0x1, 0xc6, 0x9, 0xff, 0x7, 0x0, 0x9, 0xff, 0x1, 0xeb, 0xd, 0x0, 0xe, 0xff, 0x28, 0x0, 0xf, 0xff, 0xc, 0x0, 0xa, 0xff, 0x5, 0x0, 0xa, 0xff, 0xc, 0x0, 0xf, 0xff, 0x2a, 0x0, 0x10, 0xff, 0xb, 0x0, 0xa, 0xff, 0x3, 0x0, 0xa, 0xff, 0xb, 0x0, 0x10, 0xff, 0x2c, 0x0, 0x10, 0xff, 0x1, 0xca, 0x9, 0x0, 0xa, 0xff, 0x1, 0x2e, 0x1, 0x0, 0x1, 0x10, 0xa, 0xff, 0x9, 0x0, 0x1, 0xb1, 0x10, 0xff, 0x2e, 0x0, 0x1, 0x3e, 0x11, 0xff, 0x8, 0x0, 0xa, 0xff, 0x1, 0x0, 0xa, 0xff, 0x8, 0x0, 0x11, 0xff, 0x1, 0x3e, 0x31, 0x0, 0x1, 0xfb, 0x12, 0xff, 0x1, 0x7, 0x4, 0x0, 0x1, 0x69, 0x13, 0xff, 0x1, 0x9e, 0x4, 0x0, 0x1, 0x4f, 0x12, 0xff, 0x1, 0xfb, 0x34, 0x0, 0x1, 0x69, 0x14, 0xff, 0x1, 0xca, 0x2, 0x0, 0x13, 0xff, 0x2, 0x0, 0x1, 0xbf, 0x14, 0xff, 0x1, 0x69, 0x37, 0x0, 0x3f, 0xff, 0x3a, 0x0, 0x1, 0x6d, 0x3b, 0xff, 0x1, 0x4, 0x3d, 0x0, 0x1, 0x4, 0x37, 0xff, 0x1, 0x4, 0x41, 0x0, 0x1, 0x52, 0x33, 0xff, 0x1, 0x52, 0x45, 0x0, 0x1, 0x16, 0x2f, 0xff, 0x1, 0x16, 0x49, 0x0, 0x1, 0x1, 0x2b, 0xff, 0x1, 0x1, 0x4f, 0x0, 0x1, 0xe5, 0x23, 0xff, 0x1, 0xe7, 0x56, 0x0, 0x1, 0x7d, 0x1d, 0xff, 0x1, 0x32, 0x5d, 0x0, 0x1, 0x38, 0x15, 0xff, 0x1, 0x39, 0x30, 0x0
		};

		static const std::uint16_t shift_lowercase_120x120[] = {
			0x99a, 0x0, 0x1, 0x4, 0x1, 0x2f, 0x1, 0x65, 0x1, 0x2f, 0x1, 0x4, 0x6f, 0x0, 0x1, 0x7, 0xb, 0xff, 0x1, 0x7, 0x69, 0x0, 0x1, 0x6, 0xf, 0xff, 0x1, 0x7, 0x65, 0x0, 0x1, 0xc, 0x13, 0xff, 0x1, 0x11, 0x62, 0x0, 0x1, 0xf3, 0x15, 0xff, 0x1, 0xf7, 0x60, 0x0, 0x1, 0xb0, 0xa, 0xff, 0x1, 0xca, 0x1, 0x76, 0x1, 0xca, 0xa, 0xff, 0x1, 0xb8, 0x5e, 0x0, 0x1, 0xb3, 0x8, 0xff, 0x9, 0x0, 0x8, 0xff, 0x1, 0xb1, 0x5c, 0x0, 0x7, 0xff, 0x1, 0x83, 0xd, 0x0, 0x1, 0x75, 0x7, 0xff, 0x5a, 0x0, 0x7, 0xff, 0x1, 0x45, 0xf, 0x0, 0x1, 0x3b, 0x6, 0xff, 0x1, 0x2b, 0x58, 0x0, 0x1, 0xe, 0x6, 0xff, 0x1, 0x9, 0x11, 0x0, 0x1, 0xa, 0x6, 0xff, 0x1, 0xd, 0x56, 0x0, 0x1, 0xb3, 0x6, 0xff, 0x15, 0x0, 0x6, 0xff, 0x1, 0xb0, 0x54, 0x0, 0x1, 0x78, 0x6, 0xff, 0x17, 0x0, 0x6, 0xff, 0x1, 0x74, 0x53, 0x0, 0x6, 0xff, 0x1, 0xa1, 0x17, 0x0, 0x1, 0xa4, 0x6, 0xff, 0x52, 0x0, 0x6, 0xff, 0x1, 0xd6, 0x19, 0x0, 0x1, 0xd8, 0x6, 0xff, 0x4f, 0x0, 0x1, 0x2, 0x6, 0xff, 0x1, 0x21, 0x1b, 0x0, 0x1, 0x22, 0x6, 0xff, 0x1, 0x2, 0x4d, 0x0, 0x6, 0xff, 0x1, 0x53, 0x1d, 0x0, 0x7, 0xff, 0x4c, 0x0, 0x7, 0xff, 0x1f, 0x0, 0x7, 0xff, 0x4a, 0x0, 0x7, 0xff, 0x21, 0x0, 0x7, 0xff, 0x48, 0x0, 0x6, 0xff, 0x1, 0xf7, 0x23, 0x0, 0x1, 0xf9, 0x6, 0xff, 0x46, 0x0, 0x7, 0xff, 0x25, 0x0, 0x7, 0xff, 0x44, 0x0, 0x7, 0xff, 0x27, 0x0, 0x7, 0xff, 0x42, 0x0, 0x1, 0xfd, 0x6, 0xff, 0x29, 0x0, 0x6, 0xff, 0x1, 0xfb, 0x40, 0x0, 0x7, 0xff, 0x2b, 0x0, 0x7, 0xff, 0x3e, 0x0, 0x7, 0xff, 0x2d, 0x0, 0x7, 0xff, 0x3c, 0x0, 0x7, 0xff, 0x2f, 0x0, 0x6, 0xff, 0x1, 0x61, 0x3a, 0x0, 0x1, 0xfd, 0x6, 0xff, 0x31, 0x0, 0x6, 0xff, 0x1, 0xfb, 0x38, 0x0, 0x1, 0xe3, 0x6, 0xff, 0x33, 0x0, 0x6, 0xff, 0x1, 0xe0, 0x36, 0x0, 0x1, 0xb3, 0x6, 0xff, 0x35, 0x0, 0x6, 0xff, 0x1, 0xb0, 0x35, 0x0, 0x6, 0xff, 0x1, 0x64, 0x35, 0x0, 0x1, 0x65, 0x6, 0xff, 0x33, 0x0, 0x1, 0x2d, 0x6, 0xff, 0x1, 0x1, 0x37, 0x0, 0x1, 0x1, 0x6, 0xff, 0x1, 0x29, 0x30, 0x0, 0x1, 0xe, 0x6, 0xff, 0x1, 0x9, 0x39, 0x0, 0x1, 0x9, 0x6, 0xff, 0x1, 0xc, 0x2e, 0x0, 0x1, 0x2, 0x6, 0xff, 0x1, 0x21, 0x3b, 0x0, 0x1, 0xfd, 0x6, 0xff, 0x1, 0x2, 0x2d, 0x0, 0x7, 0xff, 0x3d, 0x0, 0x7, 0xff, 0x2c, 0x0, 0x6, 0xff, 0x1, 0xa3, 0x3f, 0x0, 0x1, 0xa4, 0x6, 0xff, 0x2a, 0x0, 0x6, 0xff, 0x1, 0xd6, 0x41, 0x0, 0x1, 0xd8, 0x6, 0xff, 0x28, 0x0, 0x7, 0xff, 0x43, 0x0, 0x7, 0xff, 0x26, 0x0, 0x7, 0xff, 0x45, 0x0, 0x7, 0xff, 0x24, 0x0, 0x7, 0xff, 0x22, 0x0, 0x1, 0x2c, 0x1, 0xff, 0x1, 0x2c, 0x22, 0x0, 0x7, 0xff, 0x22, 0x0, 0x7, 0xff, 0x22, 0x0, 0x1, 0xf9, 0x3, 0xff, 0x1, 0xf9, 0x22, 0x0, 0x7, 0xff, 0x20, 0x0, 0x7, 0xff, 0x22, 0x0, 0x1, 0xda, 0x5, 0xff, 0x1, 0xda, 0x22, 0x0, 0x7, 0xff, 0x1e, 0x0, 0x7, 0xff, 0x22, 0x0, 0x1, 0x98, 0x7, 0xff, 0x1, 0x98, 0x22, 0x0, 0x7, 0xff, 0x1c, 0x0, 0x7, 0xff, 0x22, 0x0, 0x1, 0x58, 0x9, 0xff, 0x1, 0x59, 0x22, 0x0, 0x7, 0xff, 0x1a, 0x0, 0x1, 0xfd, 0x6, 0xff, 0x22, 0x0, 0x1, 0x23, 0xb, 0xff, 0x1, 0x24, 0x22, 0x0, 0x6, 0xff, 0x1, 0xfb, 0x18, 0x0, 0x1, 0xe3, 0x6, 0xff, 0x22, 0x0, 0x1, 0xa, 0x6, 0xff, 0x1, 0xe9, 0x6, 0xff, 0x1, 0xa, 0x22, 0x0, 0x6, 0xff, 0x1, 0xe0, 0x16, 0x0, 0x1, 0xa4, 0x6, 0xff, 0x23, 0x0, 0x6, 0xff, 0x1, 0x34, 0x1, 0x0, 0x1, 0x34, 0x6, 0xff, 0x23, 0x0, 0x6, 0xff, 0x1, 0xa0, 0x14, 0x0, 0x1, 0x66, 0x6, 0xff, 0x23, 0x0, 0x6, 0xff, 0x1, 0x71, 0x3, 0x0, 0x1, 0x71, 0x6, 0xff, 0x23, 0x0, 0x6, 0xff, 0x1, 0x60, 0x12, 0x0, 0x1, 0x2c, 0x6, 0xff, 0x1, 0x1, 0x22, 0x0, 0x6, 0xff, 0x1, 0xae, 0x5, 0x0, 0x1, 0xae, 0x6, 0xff, 0x22, 0x0, 0x1, 0x1, 0x6, 0xff, 0x1, 0x28, 0x10, 0x0, 0x1, 0xe, 0x6, 0xff, 0x1, 0x9, 0x22, 0x0, 0x7, 0xff, 0x7, 0x0, 0x7, 0xff, 0x22, 0x0, 0x1, 0xe1, 0x6, 0xff, 0x1, 0xc, 0xe, 0x0, 0x1, 0x1, 0x6, 0xff, 0x1, 0x2b, 0x22, 0x0, 0x7, 0xff, 0x9, 0x0, 0x7, 0xff, 0x22, 0x0, 0x1, 0x2b, 0x6, 0xff, 0x1, 0x1, 0xd, 0x0, 0x6, 0xff, 0x1, 0x64, 0x22, 0x0, 0x7, 0xff, 0xb, 0x0, 0x7, 0xff, 0x22, 0x0, 0x1, 0x64, 0x6, 0xff, 0xc, 0x0, 0x6, 0xff, 0x1, 0xa3, 0x22, 0x0, 0x7, 0xff, 0xd, 0x0, 0x7, 0xff, 0x22, 0x0, 0x1, 0xa3, 0x6, 0xff, 0xa, 0x0, 0x7, 0xff, 0x22, 0x0, 0x7, 0xff, 0xf, 0x0, 0x7, 0xff, 0x22, 0x0, 0x7, 0xff, 0x8, 0x0, 0x6, 0xff, 0x1, 0xfd, 0x22, 0x0, 0x7, 0xff, 0x11, 0x0, 0x7, 0xff, 0x22, 0x0, 0x1, 0xfd, 0x6, 0xff, 0x6, 0x0, 0x1, 0xe3, 0x6, 0xff, 0x22, 0x0, 0x7, 0xff, 0x13, 0x0, 0x7, 0xff, 0x22, 0x0, 0x6, 0xff, 0x1, 0xe5, 0x5, 0x0, 0x6, 0xff, 0x22, 0x0, 0x7, 0xff, 0x15, 0x0, 0x7, 0xff, 0x22, 0x0, 0x6, 0xff, 0x4, 0x0, 0x6, 0xff, 0x22, 0x0, 0x7, 0xff, 0x17, 0x0, 0x7, 0xff, 0x22, 0x0, 0x6, 0xff, 0x3, 0x0, 0x5, 0xff, 0x1, 0x2, 0x21, 0x0, 0x1, 0xd1, 0x6, 0xff, 0x19, 0x0, 0x6, 0xff, 0x1, 0xcb, 0x21, 0x0, 0x1, 0x1, 0x5, 0xff, 0x2, 0x0, 0x6, 0xff, 0x21, 0x0, 0x1, 0x99, 0x6, 0xff, 0x1b, 0x0, 0x6, 0xff, 0x1, 0x95, 0x21, 0x0, 0x6, 0xff, 0x1, 0x0, 0x5, 0xff, 0x1, 0x1, 0x20, 0x0, 0x1, 0x5a, 0x6, 0xff, 0x1d, 0x0, 0x6, 0xff, 0x1, 0x55, 0x20, 0x0, 0x1, 0x1, 0x5, 0xff, 0x1, 0x0, 0x5, 0xff, 0x20, 0x0, 0x1, 0xf9, 0x6, 0xff, 0x1e, 0x0, 0x1, 0x3, 0x6, 0xff, 0x1, 0xf9, 0x20, 0x0, 0x5, 0xff, 0x1, 0x7, 0x5, 0xff, 0x1f, 0x0, 0x1, 0x7, 0x6, 0xff, 0x1, 0x12, 0x1f, 0x0, 0x1, 0x11, 0x6, 0xff, 0x1, 0x6, 0x1f, 0x0, 0x5, 0xff, 0x1, 0x72, 0x4, 0xff, 0x1, 0x98, 0x1e, 0x0, 0x1, 0x1, 0x6, 0xff, 0x1, 0x36, 0x21, 0x0, 0x1, 0x35, 0x6, 0xff, 0x1f, 0x0, 0x1, 0x95, 0x4, 0xff, 0x1, 0xc3, 0x4, 0xff, 0x1, 0x36, 0x1e, 0x0, 0x6, 0xff, 0x1, 0x74, 0x23, 0x0, 0x1, 0x71, 0x6, 0xff, 0x1e, 0x0, 0x1, 0x36, 0x4, 0xff, 0x1, 0xc4, 0x4, 0xff, 0x1, 0x39, 0x1c, 0x0, 0x1, 0x24, 0x6, 0xff, 0x1, 0xbd, 0x25, 0x0, 0x1, 0xbd, 0x6, 0xff, 0x1, 0x23, 0x1c, 0x0, 0x1, 0x39, 0x4, 0xff, 0x1, 0x76, 0x4, 0xff, 0x1, 0x9c, 0x1c, 0x0, 0x6, 0xff, 0x1, 0xe9, 0x27, 0x0, 0x1, 0xe9, 0x6, 0xff, 0x1c, 0x0, 0x1, 0x9c, 0x4, 0xff, 0x1, 0x7, 0x5, 0xff, 0x1b, 0x0, 0x7, 0xff, 0x29, 0x0, 0x7, 0xff, 0x1b, 0x0, 0x5, 0xff, 0x1, 0x0, 0x5, 0xff, 0x1a, 0x0, 0x7, 0xff, 0x2b, 0x0, 0x7, 0xff, 0x1a, 0x0, 0x5, 0xff, 0x1, 0x0, 0x5, 0xff, 0x1, 0x2, 0x18, 0x0, 0x7, 0xff, 0x2d, 0x0, 0x7, 0xff, 0x18, 0x0, 0x1, 0x2, 0x5, 0xff, 0x1, 0x0, 0x6, 0xff, 0x17, 0x0, 0x7, 0xff, 0x2f, 0x0, 0x7, 0xff, 0x17, 0x0, 0x6, 0xff, 0x2, 0x0, 0x5, 0xff, 0x1, 0x2, 0x15, 0x0, 0x7, 0xff, 0x31, 0x0, 0x7, 0xff, 0x15, 0x0, 0x1, 0x2, 0x5, 0xff, 0x3, 0x0, 0x6, 0xff, 0x14, 0x0, 0x7, 0xff, 0x33, 0x0, 0x7, 0xff, 0x14, 0x0, 0x6, 0xff, 0x4, 0x0, 0x6, 0xff, 0x12, 0x0, 0x7, 0xff, 0x35, 0x0, 0x7, 0xff, 0x12, 0x0, 0x6, 0xff, 0x5, 0x0, 0x1, 0xd1, 0x6, 0xff, 0x10, 0x0, 0x7, 0xff, 0x37, 0x0, 0x7, 0xff, 0x10, 0x0, 0x6, 0xff, 0x1, 0xd1, 0x6, 0x0, 0x7, 0xff, 0xe, 0x0, 0x7, 0xff, 0x39, 0x0, 0x7, 0xff, 0xe, 0x0, 0x7, 0xff, 0x8, 0x0, 0x8, 0xff, 0x1, 0x16, 0x8, 0x0, 0x1, 0x5, 0x8, 0xff, 0x3b, 0x0, 0x8, 0xff, 0x1, 0x4, 0x8, 0x0, 0x1, 0x16, 0x8, 0xff, 0xa, 0x0, 0xb, 0xff, 0x1, 0x96, 0x1, 0x90, 0xb, 0xff, 0x3d, 0x0, 0xb, 0xff, 0x1, 0x90, 0x1, 0x96, 0xb, 0xff, 0xc, 0x0, 0x16, 0xff, 0x3f, 0x0, 0x16, 0xff, 0xe, 0x0, 0x14, 0xff, 0x41, 0x0, 0x14, 0xff, 0x11, 0x0, 0x10, 0xff, 0x45, 0x0, 0x10, 0xff, 0x15, 0x0, 0x1, 0xda, 0xa, 0xff, 0x1, 0x7d, 0x49, 0x0, 0x1, 0x86, 0xa, 0xff, 0x1, 0xda, 0x1b, 0x0, 0x1, 0x1f, 0x1, 0x4c, 0x1, 0x53, 0x1, 0x1d, 0x51, 0x0, 0x1, 0x1d, 0x1, 0x53, 0x1, 0x4c, 0x1, 0x1f, 0x8f7, 0x0
		};
		static const std::uint16_t shift_uppercase_120x120[] = {
			0x99a, 0x0, 0x1, 0x4, 0x1, 0x2f, 0x1, 0x65, 0x1, 0x2f, 0x1, 0x4, 0x6f, 0x0, 0x1, 0x7, 0xb, 0xff, 0x1, 0x7, 0x69, 0x0, 0x1, 0x6, 0xf, 0xff, 0x1, 0x7, 0x65, 0x0, 0x1, 0xc, 0x13, 0xff, 0x1, 0x11, 0x62, 0x0, 0x1, 0xf3, 0x15, 0xff, 0x1, 0xf7, 0x60, 0x0, 0x1, 0xb0, 0x17, 0xff, 0x1, 0xb8, 0x5e, 0x0, 0x1, 0xb3, 0x19, 0xff, 0x1, 0xb1, 0x5c, 0x0, 0x1d, 0xff, 0x5a, 0x0, 0x1e, 0xff, 0x1, 0x2b, 0x58, 0x0, 0x1, 0xe, 0x1f, 0xff, 0x1, 0xd, 0x56, 0x0, 0x1, 0xb3, 0x21, 0xff, 0x1, 0xb0, 0x54, 0x0, 0x1, 0x78, 0x23, 0xff, 0x1, 0x74, 0x53, 0x0, 0x25, 0xff, 0x52, 0x0, 0x27, 0xff, 0x4f, 0x0, 0x1, 0x2, 0x29, 0xff, 0x1, 0x2, 0x4d, 0x0, 0x2b, 0xff, 0x4c, 0x0, 0x2d, 0xff, 0x4a, 0x0, 0x2f, 0xff, 0x48, 0x0, 0x31, 0xff, 0x46, 0x0, 0x33, 0xff, 0x44, 0x0, 0x35, 0xff, 0x42, 0x0, 0x1, 0xfd, 0x35, 0xff, 0x1, 0xfb, 0x40, 0x0, 0x39, 0xff, 0x3e, 0x0, 0x3b, 0xff, 0x3c, 0x0, 0x3c, 0xff, 0x1, 0x61, 0x3a, 0x0, 0x1, 0xfd, 0x3d, 0xff, 0x1, 0xfb, 0x38, 0x0, 0x1, 0xe3, 0x3f, 0xff, 0x1, 0xe0, 0x36, 0x0, 0x1, 0xb3, 0x41, 0xff, 0x1, 0xb0, 0x35, 0x0, 0x43, 0xff, 0x33, 0x0, 0x1, 0x2d, 0x45, 0xff, 0x1, 0x29, 0x30, 0x0, 0x1, 0xe, 0x47, 0xff, 0x1, 0xc, 0x2e, 0x0, 0x1, 0x2, 0x49, 0xff, 0x1, 0x2, 0x2d, 0x0, 0x4b, 0xff, 0x2c, 0x0, 0x4d, 0xff, 0x2a, 0x0, 0x4f, 0xff, 0x28, 0x0, 0x51, 0xff, 0x26, 0x0, 0x53, 0xff, 0x24, 0x0, 0x55, 0xff, 0x22, 0x0, 0x57, 0xff, 0x20, 0x0, 0x59, 0xff, 0x1e, 0x0, 0x5b, 0xff, 0x1c, 0x0, 0x5d, 0xff, 0x1a, 0x0, 0x1, 0xfd, 0x5d, 0xff, 0x1, 0xfb, 0x18, 0x0, 0x1, 0xe3, 0x2f, 0xff, 0x1, 0xe9, 0x2f, 0xff, 0x1, 0xe0, 0x16, 0x0, 0x1, 0xa4, 0x2f, 0xff, 0x1, 0x34, 0x1, 0x0, 0x1, 0x34, 0x2f, 0xff, 0x1, 0xa0, 0x14, 0x0, 0x1, 0x66, 0x2f, 0xff, 0x1, 0x71, 0x3, 0x0, 0x1, 0x71, 0x2f, 0xff, 0x1, 0x60, 0x12, 0x0, 0x1, 0x2c, 0x2f, 0xff, 0x1, 0xae, 0x5, 0x0, 0x1, 0xae, 0x2f, 0xff, 0x1, 0x28, 0x10, 0x0, 0x1, 0xe, 0x30, 0xff, 0x7, 0x0, 0x30, 0xff, 0x1, 0xc, 0xe, 0x0, 0x1, 0x1, 0x30, 0xff, 0x9, 0x0, 0x30, 0xff, 0x1, 0x1, 0xd, 0x0, 0x30, 0xff, 0xb, 0x0, 0x30, 0xff, 0xc, 0x0, 0x30, 0xff, 0xd, 0x0, 0x30, 0xff, 0xa, 0x0, 0x30, 0xff, 0xf, 0x0, 0x30, 0xff, 0x8, 0x0, 0x30, 0xff, 0x11, 0x0, 0x30, 0xff, 0x6, 0x0, 0x1, 0xe3, 0x2f, 0xff, 0x13, 0x0, 0x2f, 0xff, 0x1, 0xe5, 0x5, 0x0, 0x2f, 0xff, 0x15, 0x0, 0x2f, 0xff, 0x4, 0x0, 0x2f, 0xff, 0x17, 0x0, 0x2f, 0xff, 0x3, 0x0, 0x2e, 0xff, 0x19, 0x0, 0x2e, 0xff, 0x2, 0x0, 0x2e, 0xff, 0x1b, 0x0, 0x2e, 0xff, 0x1, 0x0, 0x2d, 0xff, 0x1d, 0x0, 0x2d, 0xff, 0x1, 0x0, 0x2c, 0xff, 0x1e, 0x0, 0x1, 0x3, 0x2c, 0xff, 0x1, 0x7, 0x2b, 0xff, 0x1, 0x13, 0x1f, 0x0, 0x1, 0x11, 0x2b, 0xff, 0x1, 0x72, 0x2a, 0xff, 0x1, 0x38, 0x21, 0x0, 0x1, 0x33, 0x2a, 0xff, 0x1, 0xc3, 0x29, 0xff, 0x1, 0x76, 0x23, 0x0, 0x1, 0x70, 0x29, 0xff, 0x1, 0xc4, 0x28, 0xff, 0x1, 0xc1, 0x25, 0x0, 0x1, 0xbc, 0x28, 0xff, 0x1, 0x76, 0x27, 0xff, 0x1, 0xeb, 0x27, 0x0, 0x1, 0xe7, 0x27, 0xff, 0x1, 0x7, 0x27, 0xff, 0x29, 0x0, 0x27, 0xff, 0x1, 0x0, 0x26, 0xff, 0x2b, 0x0, 0x26, 0xff, 0x1, 0x0, 0x25, 0xff, 0x2d, 0x0, 0x25, 0xff, 0x1, 0x0, 0x24, 0xff, 0x2f, 0x0, 0x24, 0xff, 0x2, 0x0, 0x22, 0xff, 0x31, 0x0, 0x22, 0xff, 0x3, 0x0, 0x21, 0xff, 0x33, 0x0, 0x21, 0xff, 0x4, 0x0, 0x1f, 0xff, 0x35, 0x0, 0x1f, 0xff, 0x5, 0x0, 0x1, 0xd1, 0x1d, 0xff, 0x37, 0x0, 0x1d, 0xff, 0x1, 0xd1, 0x6, 0x0, 0x1c, 0xff, 0x39, 0x0, 0x1c, 0xff, 0x8, 0x0, 0x1a, 0xff, 0x3b, 0x0, 0x1a, 0xff, 0xa, 0x0, 0x18, 0xff, 0x3d, 0x0, 0x18, 0xff, 0xc, 0x0, 0x16, 0xff, 0x3f, 0x0, 0x16, 0xff, 0xe, 0x0, 0x14, 0xff, 0x41, 0x0, 0x14, 0xff, 0x11, 0x0, 0x10, 0xff, 0x45, 0x0, 0x10, 0xff, 0x15, 0x0, 0x1, 0xda, 0xa, 0xff, 0x1, 0x7d, 0x49, 0x0, 0x1, 0x86, 0xa, 0xff, 0x1, 0xda, 0x1b, 0x0, 0x1, 0x1f, 0x1, 0x4c, 0x1, 0x53, 0x1, 0x1d, 0x51, 0x0, 0x1, 0x1d, 0x1, 0x53, 0x1, 0x4c, 0x1, 0x1f, 0x8f7, 0x0
		};

		struct images
		{
			paint::pixel_buffer backspace;
			paint::pixel_buffer earth;
			paint::pixel_buffer shift_lowercase;
			paint::pixel_buffer shift_uppercase;
		};

		class numeric:
			public nana::panel<true>
		{
			struct key_rep
			{
				char value;
				nana::rectangle r;
			};
		public:
			static constexpr unsigned border_px = 5;
			static constexpr unsigned button_border_px = 2;

			numeric(window wd, window host, const keyboards::images* images ):
				panel<true>(wd),
				window_(wd),
				host_(host),
				images_(images)
			{
				const char values[] = "\r789456123.0\b";
				for (int i = 0; i < 13; ++i)
					keys_.emplace_back().value = values[i];

				api::window_size(wd, { 320, 320 });
				this->size({ 320, 320 });

				_m_resized();

				nana::drawing{ *this }.draw([this](nana::paint::graphics& graph) {
					_m_render(graph);
				});
				
				api::refresh_window(*this);

				this->events().mouse_down([this](const nana::arg_mouse& arg) {
					pressed_key_ = 0;
					for (auto& key : keys_)
						if (key.r.is_hit(arg.pos))
						{
							pressed_key_ = key.value;
						}

					nana::api::refresh_window(*this);
					});

				this->events().mouse_up([this] {
					if(_m_input())
						nana::api::refresh_window(*this);
					});

				this->events().dbl_click([this](const nana::arg_mouse& arg) {
					pressed_key_ = 0;
					for (auto& key : keys_) {
						if (key.r.is_hit(arg.pos))
							pressed_key_ = key.value;
					}

					if(_m_input())
						nana::api::refresh_window(*this);
				});
			}
		private:
			bool _m_input()
			{
				if ('\r' == pressed_key_)
				{
					api::close_window(window_);
					return false;
				}
				else if (pressed_key_)
				{
					auto caret_pos = nana::api::dev::caret_position(host_).value();

					std::wstring text;
					text += pressed_key_;

					nana::api::dev::im_input(host_, caret_pos, text, false);
				}

				pressed_key_ = 0;
				return true;
			}

			void _m_resized()
			{
				auto sz = this->size();

				if (sz.width <= border_px * 2 || sz.height <= border_px * 2)
					return;

				sz.width -= border_px * 2;
				sz.height -= border_px * 2;

				auto row = sz.height / 5;
				auto col = sz.width / 3;

				if (row <= 2 * button_border_px || col <= 2 * button_border_px)
					return;

				std::vector<int> rows;

				for (int i = 0; i < 5; ++i)
				{
					rows.push_back(static_cast<int>(border_px) + i * row);
				}

				int left = static_cast<int>(border_px);


				keys_[0].r = nana::rectangle{ left + static_cast<int>(2 * col), rows[0], col, row };

				int idx = 1;
				for (int y = 0; y < 4; ++y)
					for (int x = 0; x < 3; ++x)
					{
						keys_[idx++].r = nana::rectangle{ left + static_cast<int>(x * col), rows[y + 1], col, row };
					}
			}

			void _m_render(nana::paint::graphics& graph)
			{
				for (auto& key : keys_)
				{
					auto r = key.r;

					r.pare_off(button_border_px);
					if (pressed_key_ == key.value)
						r.pare_off(-2);

					graph.rectangle(r, true, _m_key_color(key.value));

					if ('\b' == key.value)
					{
						auto& img = images_->backspace;

						unsigned size = r.height * 3 / 5;

						auto pos = r.position();
						pos.x += (r.width - size) / 2;
						pos.y += (r.height - size) / 2;
						img.stretch(nana::rectangle{ img.size() }, graph.handle(), nana::rectangle{ pos, nana::size{size, size} });
					}
					else
					{
						std::wstring text;

						auto col = nana::colors::black;

						if ('\r' == key.value)
						{
							text = L"Done";
							col = nana::colors::white;
						}
						else
							text += key.value;

						auto text_sz = graph.text_extent_size(text);

						nana::point text_pos{ key.r.x + static_cast<int>(key.r.width - text_sz.width) / 2,  key.r.y + static_cast<int>(key.r.height - text_sz.height) / 2 };
						graph.string(text_pos, text, col);
					}
				}
			}
		private:
			nana::color_rgb _m_key_color(char key)
			{
				if ('\r' == key)
					return static_cast<nana::color_rgb>(0x2B7DFB);

				return static_cast<nana::color_rgb>(0xFEFEFE);
			}
		private:
			window const window_;
			window const host_;
			const keyboards::images* const images_;
			std::vector<key_rep> keys_;
			char pressed_key_{ 0 };
			int offset_{ 0 };
		};


		class qwerty
			: public nana::panel<true>
		{
		public:
			static const unsigned topbar_px = 48;
			static const unsigned bottom_px = 32;
			static const unsigned height_px = 280;

			using labels = im_interface::labels;

			using behaves = virtual_keyboard::behaves;
			using modes = virtual_keyboard::modes;

			enum class key_types
			{
				character,	///< Character keys
				digital,	///< digital keys
				symbol,	///< symbol keys
				shift,
				backspace,
				enter,
				whitespace,
				mode_switch,
				lang_switch

			};

			struct key_rep
			{
				nana::rectangle r;
				wchar_t value{ 0 };
				key_types type{ key_types::character };

				key_rep() = default;

				key_rep(const nana::rectangle& r) :
					r(r)
				{}

				key_rep(const nana::rectangle& r, wchar_t value, key_types type) :
					r(r),
					value(value),
					type(type)
				{}
			};

			qwerty(nana::window wd, nana::window text_wd, std::vector<std::string>& langs, behaves behave, modes mode, const keyboards::images* images) :
				nana::panel<true>(wd, nana::rectangle{}, true),
				window_(wd),
				images_(images),
				langs_(langs),
				mode_(mode),
				behave_(behave),
				im_(_m_default_im())
			{
				cntpart_.lang = im_->lang();

				nana::size dim{ 480, 280 };

				api::window_size(window_, dim);
				this->size(dim);

				auto r = _m_make_metrics();

				_m_assign_key_values();

				this->move(r);
				this->bgcolor(static_cast<nana::color_rgb>(0xD3D6DF));

				cntpart_.graph.make(r.dimension());

				nana::drawing{ *this }.draw([this](nana::paint::graphics& graph) {
					_m_render(graph);
					});

				this->events().mouse_down([this, text_wd](const nana::arg_mouse& arg) {

					if (arg.left_button && (_m_candidate_hitted(arg.pos) || !candidate_.single_mode))
					{
						candidate_.origin_arg_pos = arg.pos;
						candidate_.origin.x = candidate_.left;
						candidate_.origin.y = candidate_.top;
						candidate_.state = 1;
						return;
					}
					_m_press_key(text_wd, arg.pos, true);
					});

				this->events().mouse_move([this](const nana::arg_mouse& arg) {
					if (1 == candidate_.state || 2 == candidate_.state)
					{
						candidate_.state = 2;

						if (candidate_.single_mode)
						{
							//Single line mode, horizontal scrolling only
							auto left = candidate_.origin.x - (candidate_.origin_arg_pos.x - arg.pos.x);

							left = std::clamp(left, key_candidate_switch_.x - static_cast<int>(candidate_.content_px), 0);

							if (left != candidate_.left)
							{
								candidate_.left = left;
								nana::api::refresh_window(*this);
							}
						}
						else
						{
							//Multiline mode, vertical scrolling only
							auto top = candidate_.origin.y - (candidate_.origin_arg_pos.y - arg.pos.y);

							top = std::clamp(top, static_cast<int>(this->size().height) - static_cast<int>(candidate_.content_px), 0);
							if (top != candidate_.top)
							{
								candidate_.top = top;
								nana::api::refresh_window(*this);
							}
						}
					}
					});

				this->events().mouse_up([this, text_wd](const nana::arg_mouse& arg) {
					if (1 == candidate_.state)
					{
						pressed_key_ = 0;
						_m_press_key(text_wd, arg.pos);
					}
					else if (pressed_key_)
					{
						pressed_key_ = 0;
						nana::api::refresh_window(*this);
					}

					candidate_.state = 0;
					});

				this->events().dbl_click([this, text_wd](const nana::arg_mouse& arg) {
					pressed_key_ = 0;
					_m_press_key(text_wd, arg.pos);
					});


				api::refresh_window(*this);
			}
		private:
			static std::unique_ptr<im_interface> _m_im_from_lang(const std::string& lang)
			{
				if (lang == "en")
					return std::make_unique<im_english>();
				else if (lang == "zh-CN")
					return std::make_unique<im_pinyin>();
				else if (lang == "ru")
					return std::make_unique<im_russian>();

				return std::make_unique<im_english>();
			}

			static std::unique_ptr<im_interface> _m_default_im()
			{
				return _m_im_from_lang("en");
			}

			void _m_press_key(nana::window text_wd, const nana::point& arg_pos, bool is_pressed = false)
			{
				if (key_candidate_switch_.is_hit(arg_pos))
				{
					candidate_.single_mode = !candidate_.single_mode;
					nana::api::refresh_window(*this);
					return;
				}

				if (_m_candidate_picked(text_wd, arg_pos))
				{
					nana::api::refresh_window(*this);
					return;
				}
				else if (!candidate_.single_mode)
					//Exits if it is multiline mode, otherwise it mistakely processes key actions
					return;

				for (auto& key : keys_)
				{
					if (key.r.is_hit(arg_pos))
					{
						if (key_types::character == key.type || key_types::symbol == key.type || key_types::digital == key.type || key_types::backspace == key.type || key_types::whitespace == key.type)
						{
							_m_put(text_wd, key.value);
							if (modes::letter_upper == mode_ && key_types::character == key.type)
							{
								mode_ = modes::letter_lower;
								_m_make_metrics();
								_m_assign_key_values();
							}

							if (is_pressed)
								pressed_key_ = key.value;
							nana::api::refresh_window(*this);
						}
						else if (key_types::mode_switch == key.type)
						{
							if (modes::letter_lower != mode_ && modes::letter_upper != mode_)
								_m_change_mode(modes::letter_lower);
							else
								_m_change_mode(modes::digital);
						}
						else if (key_types::enter == key.type)
						{
							if (behaves::done == behave_)
							{
								auto wd = nana::api::root(nana::api::root(text_wd));
								nana::api::focus_window(wd);
							}
						}
						else if (key_types::shift == key.type)
						{
							if (modes::letter_lower == mode_)
								_m_change_mode(modes::letter_upper);
							else if (modes::letter_upper == mode_)
								_m_change_mode(modes::letter_lower);
							else if (modes::digital == mode_)
								_m_change_mode(modes::symbol);
							else if (modes::symbol == mode_)
								_m_change_mode(modes::digital);
						}
						else if (key_types::lang_switch == key.type)
						{
							auto langs = langs_;

							auto lang = im_->lang();

							if (langs.size() > 1 || langs.front() != lang)
							{
								std::size_t i = 0;
								for (; i < langs.size(); ++i)
								{
									if (lang == langs[i])
										break;
								}

								++i;

								if (i < langs.size())
									im_ = _m_im_from_lang(langs[i]);
								else
									im_ = _m_im_from_lang("en");

								mode_ = modes::letter_lower;

								_m_make_metrics();

								_m_assign_key_values();
								nana::api::refresh_window(*this);
							}
						}

						break;
					}
				}
			}

			bool _m_candidate_hitted(const nana::point& pos) const
			{
				if (candidate_.word_areas.empty())
				{
					return false;
				}

				return (pos.x < key_candidate_switch_.x&& pos.y < candidate_.word_areas.front().bottom());
			}

			bool _m_candidate_picked(nana::window text_wd, nana::point pos)
			{
				std::size_t idx = 0;

				for (auto& cd_r : candidate_.word_areas)
				{
					if (cd_r.is_hit(pos))
					{
						auto content = im_->pick_candidate(idx + candidate_.offset_idx);

						insert_pos_ = nana::api::dev::im_input(text_wd, insert_pos_, content, im_->has_intermediate_input());

						candidate_.words = im_->candidates();
						candidate_.word_areas.clear();
						candidate_.left = 0;
						candidate_.top = 0;
						candidate_.single_mode = true;
						return true;
					}

					++idx;

				}

				return false;
			}

			void _m_put(nana::window text_wd, wchar_t ch)
			{
				auto caret_pos = nana::api::dev::caret_position(text_wd).value();

				bool has_intermediate_input = im_->has_intermediate_input();
				if (!has_intermediate_input)
					insert_pos_ = caret_pos;

				//The caret position may be in front of the position when starting input.
				//E.g. When the text is selected before inputting. When inputting, the selected text are deleted, the caret moves backward,
				//then the caret position is in front of the position before inputting.
				if (insert_pos_.x > caret_pos.x)
					insert_pos_.x = caret_pos.x;

				auto content = im_->input(caret_pos.x - insert_pos_.x, ch);

				if (!(im_->has_intermediate_input() || has_intermediate_input))
				{
					auto wdg = nana::api::get_widget(text_wd);

					if (dynamic_cast<nana::combox*>(wdg))
					{
						auto cmb = dynamic_cast<nana::combox*>(wdg);

						for (auto ch : content)
							cmb->put(ch);
					}
					else if (dynamic_cast<nana::textbox*>(wdg))
					{
						insert_pos_ = nana::api::dev::im_input(text_wd, caret_pos, content, false);
					}
				}
				else
				{
					insert_pos_ = nana::api::dev::im_input(text_wd, insert_pos_, content, true);

					candidate_.words = im_->candidates();
					candidate_.word_areas.clear();
				}
			}

			void _m_change_mode(modes m)
			{
				if (mode_ == m)
					return;

				mode_ = m;
				_m_make_metrics();
				_m_assign_key_values();

				nana::api::refresh_window(*this);
			}

			nana::rectangle _m_make_metrics()
			{
				keys_.clear();

				nana::rectangle r{ this->size() };
				r.x = 0;
				r.y = r.height - height_px;
				r.height = height_px;

				auto const operation_height_px = r.height - bottom_px;

				metrics_.gap_horz = static_cast<unsigned>(r.width * 0.016);
				metrics_.gap_vert = static_cast<unsigned>(operation_height_px * 0.0423);

				std::vector<int> layout = im_->layout(modes::letter_lower == mode_ || modes::letter_upper == mode_);


				auto const keys_width = r.width - (layout.front() - 1) * metrics_.gap_horz;

				metrics_.key_size.width = keys_width / layout.front();
				metrics_.left_edge = (keys_width % layout.front()) / 2;

				auto const keys_height = (operation_height_px - metrics_.gap_vert * 3 - topbar_px);
				metrics_.key_size.height = keys_height / 4;
				metrics_.top_edge = topbar_px + (keys_height % 4) / 2;

				auto const right_edge = static_cast<int>(metrics_.left_edge + metrics_.key_size.width * layout.front() + metrics_.gap_horz * (layout.front() - 1));

				auto key_r = nana::rectangle{ nana::point{metrics_.left_edge, metrics_.top_edge}, metrics_.key_size };

				for (int i = 0; i < layout[0]; ++i)
				{
					keys_.emplace_back(key_r);
					key_r.x += metrics_.key_size.width + metrics_.gap_horz;
				}

				key_r = nana::rectangle{ nana::point{metrics_.left_edge, metrics_.top_edge}, metrics_.key_size };
				key_r.x += static_cast<int>((metrics_.key_size.width + metrics_.gap_horz) * (layout[0] - layout[1])) / 2;

				key_r.y += metrics_.key_size.height + metrics_.gap_vert;

				for (int i = 0; i < layout[1]; ++i)
				{
					keys_.emplace_back(key_r);
					key_r.x += metrics_.key_size.width + metrics_.gap_horz;
				}

				key_r = nana::rectangle{ nana::point{metrics_.left_edge, metrics_.top_edge}, metrics_.key_size };
				key_r.x += ((metrics_.key_size.width + metrics_.gap_horz) * (layout[0] - layout[2])) / 2;
				key_r.y += (metrics_.key_size.height + metrics_.gap_vert) * 2;

				for (int i = 0; i < layout[2]; ++i)
				{
					keys_.emplace_back(key_r);
					key_r.x += metrics_.key_size.width + metrics_.gap_horz;
				}

				unsigned shift_width = ((metrics_.gap_horz + metrics_.key_size.width) * (layout[0] - layout[2]) / 2 + metrics_.key_size.width - metrics_.gap_horz) / 2;

				// Space
				key_r.x = metrics_.left_edge + (metrics_.key_size.width + metrics_.gap_horz) * 5 / 2;
				key_r.y = metrics_.top_edge + (metrics_.key_size.height + metrics_.gap_vert) * 3;
				key_r.width = (metrics_.key_size.width + metrics_.gap_horz) * (layout.back() - 3) + metrics_.key_size.width / 2;
				keys_.emplace_back(key_r, ' ', key_types::whitespace);

				// Dot
				key_r.x += metrics_.gap_horz + key_r.width;
				key_r.width = metrics_.key_size.width;
				keys_.emplace_back(key_r, '.', key_types::symbol);

				// Enter
				key_r.x += metrics_.gap_horz + key_r.width;
				//key_r.width = metrics_.left_edge + metrics_.key_size.width * 10 + metrics_.gap_horz * 9 - key_r.x;
				key_r.width = right_edge - key_r.x;
				keys_.emplace_back(key_r, '\r', key_types::enter);


				// Function Keys
				key_r.x = metrics_.left_edge;
				key_r.y = metrics_.top_edge + (metrics_.key_size.height + metrics_.gap_vert) * 2;
				//key_r.width = (metrics_.key_size.width * 5 / 2 + metrics_.gap_horz / 2) / 2;
				key_r.width = shift_width;

				keys_.emplace_back(key_r, 0xF, key_types::shift);	//Shift


				//Backspace
				key_r.x = right_edge - key_r.width;
				keys_.emplace_back(key_r, '\b', key_types::backspace);	//Backspace

				//Mode Switch
				key_r.x = metrics_.left_edge;
				key_r.y = metrics_.top_edge + (metrics_.key_size.height + metrics_.gap_vert) * 3;
				keys_.emplace_back(key_r, -1, key_types::mode_switch);

				//Changing Language
				key_r.x += key_r.width + metrics_.gap_horz;
				keys_.emplace_back(key_r, -1, key_types::lang_switch);

				//KeyCandidateSiwtch
				key_candidate_switch_ = nana::rectangle{ nana::size{40, topbar_px - 8} };

				key_candidate_switch_.x = r.width; //r.width - key_candidate_switch_.width - 5;
				key_candidate_switch_.y = (topbar_px - key_candidate_switch_.height) / 2;

				return r;
			}

			void _m_assign_key_values()
			{
				if (modes::letter_lower == mode_ || modes::letter_upper == mode_)
				{
					std::wstring letters = im_->letters(modes::letter_lower == mode_);

					for (std::size_t i = 0; i < letters.size(); ++i)
					{
						keys_[i].value = letters[i];
						keys_[i].type = key_types::character;
					}
				}
				else if (modes::digital == mode_)
				{
					const char values[] = "1234567890";
					for (int i = 0; i < 10; ++i)
					{
						keys_[i].value = values[i];
						keys_[i].type = key_types::digital;
					}

					auto sym = im_->digital_symbols(true);
					for (std::size_t i = 0; i < sym.size(); ++i)
					{
						keys_[i + 10].value = sym[i];
						keys_[i + 10].type = key_types::symbol;
					}

				}
				else if (modes::symbol == mode_)
				{
					auto sym = im_->digital_symbols(false);
					for (int i = 0; i < 26; ++i)
					{
						keys_[i].value = sym[i];
						keys_[i].type = key_types::symbol;
					}
				}
			}

			static nana::color_rgb _m_key_color(int key)
			{
				if (key < 0 || '\b' == key || 0xF == key)
					return static_cast<nana::color_rgb>(0xB4B8C4);
				else if ('\r' == key)
					return static_cast<nana::color_rgb>(0x2B7DFB);

				return static_cast<nana::color_rgb>(0xFEFEFE);
			}

			void _m_render_key(nana::paint::graphics& graph, const key_rep& key)
			{
				auto const key_shadow_color = static_cast<nana::color_rgb>(0xBEBF93);

				auto r = key.r;
				r.width -= 1;
				r.height -= 1;

				if (pressed_key_ == key.value)
					r.pare_off(-2);

				graph.rectangle(r, true, _m_key_color(key.value));

				if (key_types::character == key.type || key_types::digital == key.type || key_types::symbol == key.type)
				{

					auto chsize = graph.text_extent_size(std::wstring_view{ &key.value, 1 });

					auto pos = r.position();
					pos.x += (r.width - chsize.width) / 2;
					pos.y += (r.height - chsize.height) / 2;
					graph.string(pos, std::wstring_view{ &key.value, 1 });
				}
				else
				{
					if (key_types::shift == key.type)
					{
						const paint::pixel_buffer *img = nullptr;

						if (modes::letter_lower == mode_)
							img = &images_->shift_lowercase;
						else if (modes::letter_upper == mode_)
							img = &images_->shift_uppercase;

						if (img)
						{
							unsigned size = r.height * 3 / 5;

							auto pos = r.position();
							pos.x += (r.width - size) / 2;
							pos.y += (r.height - size) / 2;
							img->stretch(nana::rectangle{ img->size() }, graph.handle(), nana::rectangle{ pos, nana::size{size, size} });
						}
						else
						{
							std::string text;
							if (modes::digital == mode_)
								text = "+-=";
							else
								text = "123";

							auto ts = graph.text_extent_size(text);
							auto pos = r.position();
							pos.x += (r.width - ts.width) / 2;
							pos.y += (r.height - ts.height) / 2;
							graph.string(pos, text, nana::colors::black);
						}
					}
					else if (key_types::backspace == key.type)
					{
						auto& img = images_->backspace;

						unsigned size = r.height * 3 / 5;

						auto pos = r.position();
						pos.x += (r.width - size) / 2;
						pos.y += (r.height - size) / 2;
						img.stretch(nana::rectangle{ img.size() }, graph.handle(), nana::rectangle{ pos, nana::size{size, size} });
					}
					else if (key_types::lang_switch == key.type)
					{
						auto& img = images_->earth;

						unsigned size = r.height * 3 / 5;

						auto pos = r.position();
						pos.x += (r.width - size) / 2;
						pos.y += (r.height - size) / 2;
						img.stretch(nana::rectangle{ img.size() }, graph.handle(), nana::rectangle{ pos, nana::size{size, size} });
					}
					else if (key_types::whitespace == key.type)
					{
						std::wstring text = im_->label(labels::space);

						auto ts = graph.text_extent_size(text);
						auto pos = r.position();
						pos.x += (r.width - ts.width) / 2;
						pos.y += (r.height - ts.height) / 2;
						graph.string(pos, text, nana::colors::black);
					}
					else if (key_types::mode_switch == key.type)
					{
						std::wstring text = L"123";

						if (modes::digital == mode_ || modes::symbol == mode_)
							text = im_->label(labels::alphabet);

						auto ts = graph.text_extent_size(text);
						auto pos = r.position();
						pos.x += (r.width - ts.width) / 2;
						pos.y += (r.height - ts.height) / 2;
						graph.string(pos, text, nana::colors::black);
					}
					else if (key_types::enter == key.type)
					{
						std::wstring text;
						if (behaves::done == behave_)
							text = im_->label(labels::done);

						auto ts = graph.text_extent_size(text);
						auto pos = r.position();
						pos.x += (r.width - ts.width) / 2;
						pos.y += (r.height - ts.height) / 2;
						graph.string(pos, text, nana::colors::white);
					}
				}

				nana::point pos{ r.x + 1, r.bottom() };
				nana::point pos_rb{ r.right(), r.bottom() };
				graph.line(pos, pos_rb, key_shadow_color);

				pos.x = r.right();
				pos.y = r.y + 1;
				graph.line(pos, pos_rb, key_shadow_color);
			}

			void _m_render_keys(nana::paint::graphics& graph)
			{
				for (auto& key : keys_)
					_m_render_key(graph, key);
			}

			void _m_render(nana::paint::graphics& graph)
			{
				// 
				if (candidate_.single_mode)
				{
					if (cntpart_.mode && (cntpart_.mode.value() == mode_) && (cntpart_.lang == im_->lang()))
					{
						cntpart_.graph.paste(graph, 0, 0);

						if (pressed_key_)
						{
							for (auto& key : keys_)
							{
								if (pressed_key_ == key.value)
								{
									_m_render_key(graph, key);
									break;
								}
							}

						}
					}
					else
					{
						cntpart_.lang = im_->lang();
						cntpart_.mode = mode_;
						_m_render_keys(graph);

						graph.paste(cntpart_.graph, 0, 0);
					}
					_m_render_candidates(graph);
				}
				else
					_m_render_candidates_ml(graph);
			}

			/// 
			/**
			 * 
			 */
			void _m_render_candidates(nana::paint::graphics& graph)
			{
				candidate_.top = 0;
				candidate_.word_areas.clear();

				const int right = (graph.width() - key_candidate_switch_.width - 5);

				auto const space = (right / 13);
				auto const candidate_gap = 24;

				nana::rectangle r;
				r.x = candidate_.left;
				r.height = topbar_px;

				candidate_.offset_idx = 0;

				for (auto& cd : candidate_.words)
				{
					auto ts = graph.text_extent_size(cd);

					r.width = (static_cast<int>(ts.width) + candidate_gap >= space ? ts.width + candidate_gap : space);

					if (r.right() > 0 && (r.x + static_cast<int>(ts.width) < right))
					{
						candidate_.word_areas.push_back(r);

						nana::point pt{
							r.x,
							static_cast<int>(r.height - ts.height) / 2
						};

						graph.string(pt, cd, nana::colors::black);
					}
					else if (r.right() <= 0)
						candidate_.offset_idx++;

					r.x += r.width;
				}

				//r.x

				candidate_.content_px = (r.x - candidate_.left);



				// 
				if (candidate_.content_px > static_cast<int>(graph.width()))
				{
					key_candidate_switch_.x = right;

					nana::facade<nana::element::arrow> arrow{ "double" };

					nana::rectangle arrow_r{ key_candidate_switch_.position(), nana::size{16, 16} };
					arrow_r.x += static_cast<int>(key_candidate_switch_.width - 8) / 2;
					arrow_r.y += static_cast<int>(key_candidate_switch_.height - 16) / 2;

					arrow.direction(nana::direction::south);
					arrow.draw(graph, static_cast<nana::color_rgb>(0xD3D6DF), nana::colors::black, arrow_r, nana::element_state::normal);
				}
				else
					key_candidate_switch_.x = static_cast<int>(graph.width());
			}

			//Renders the area of multi-line candidates 
			void _m_render_candidates_ml(nana::paint::graphics& graph)
			{
				candidate_.left = 0;
				candidate_.word_areas.clear();

				const int right = (graph.width() - key_candidate_switch_.width - 5);

				auto const space = (right / 13);
				auto const candidate_gap = 24;

				nana::rectangle r;
				r.y = candidate_.top;
				r.height = topbar_px;

				candidate_.offset_idx = 0;
				for (auto& cd : candidate_.words)
				{
					auto ts = graph.text_extent_size(cd);

					r.width = (static_cast<int>(ts.width) + candidate_gap >= space ? ts.width + candidate_gap : space);

					if (r.x + static_cast<int>(ts.width) >= right)
					{
						r.x = 0;
						r.y += topbar_px;
					}

					if (r.bottom() > 0)
					{
						candidate_.word_areas.push_back(r);

						nana::point pt{
							r.x,
							r.y + static_cast<int>(r.height - ts.height) / 2
						};

						graph.string(pt, cd, nana::colors::black);
					}
					else if (r.bottom() <= 0)
						candidate_.offset_idx++;

					r.x += r.width;
				}

				candidate_.content_px = (r.bottom() - candidate_.top);


				//Candidate switch button
				key_candidate_switch_.x = right;

				nana::facade<nana::element::arrow> arrow{ "double" };

				nana::rectangle arrow_r{ key_candidate_switch_.position(), nana::size{16, 16} };
				arrow_r.x += static_cast<int>(key_candidate_switch_.width - 8) / 2;
				arrow_r.y += static_cast<int>(key_candidate_switch_.height - 16) / 2;

				arrow.direction(nana::direction::north);
				arrow.draw(graph, static_cast<nana::color_rgb>(0xD3D6DF), nana::colors::black, arrow_r, nana::element_state::normal);

			}
		private:
			window const window_;
			const keyboards::images* const images_;
			std::vector<std::string> langs_;
			modes mode_;
			behaves behave_;
			std::unique_ptr<im_interface> im_;
			struct metrics_rep
			{
				int left_edge;
				int top_edge;
				unsigned gap_horz{ 12 };
				unsigned gap_vert{ 22 };

				nana::size key_size;
			}metrics_;

			nana::rectangle	key_candidate_switch_;
			std::vector<key_rep> keys_;

			wchar_t pressed_key_{ 0 };

			nana::upoint insert_pos_;

			struct candidate
			{
				bool single_mode{ true };	///< Candidates mode: single line mode and multi-line mode
				std::size_t offset_idx{ 0 };
				int left{ 0 };
				int top{ 0 };
				int content_px{ 0 };		///< Content height, in pixel. Used for scrolling

				int state{ 0 };				///< States of event
				nana::point origin;			///< Offsets of x-axis and y-axis of candidates area when butten is pressed.
				nana::point origin_arg_pos;	///< cursor coordinates when button is pressed

				std::vector<std::wstring> words;
				std::vector<nana::rectangle> word_areas;
			}candidate_;

			struct counterpart
			{
				std::string lang;
				std::optional<modes> mode;
				nana::paint::graphics graph;
			}cntpart_;
		};

	}

	class virtual_keyboard_window:
		public nana::form
	{
	public:
		virtual_keyboard_window(window host, const keyboards::images* images):
			nana::form(host, nana::rectangle{0, 0, 100, 100 }, appear::bald<appear::floating>{}),
			host_(host),
			host_form_(nana::api::root(nana::api::root(host))),
			images_(images)
		{
			this->bgcolor(static_cast<nana::color_rgb>(0xD3D6DF));

			origin_pt_ = nana::api::window_position(host_form_);

			api::take_active(handle(), false, host);

			this->events().resized([this](const arg_resized&) {
				_m_resized();
			});

			this->show();
		}

		~virtual_keyboard_window()
		{
			api::move_window(host_form_, origin_pt_);
			delete board_;
		}

		window host() const
		{
			return host_;
		}

		void qwerty(std::vector<std::string> langs, virtual_keyboard::behaves behave, virtual_keyboard::modes mode)
		{
			board_ = new keyboards::qwerty(*this, host_, langs, behave, mode, images_);
		}

		void numeric()
		{
			board_ = new keyboards::numeric{*this, host_, images_};
		}
	private:
		/// \todo: generalize dpi to v2 awareness 
		nana::rectangle _m_place()
		{
			auto start_pt = nana::point{ 0, static_cast<int>(nana::api::window_size(host_).height + 2) };

			this->move(start_pt);

			auto const desktop_size = nana::screen::primary_monitor_size();

			auto window_sz = this->size();

			if (window_sz.width > desktop_size.width)
				window_sz.width = desktop_size.width;

			nana::point pt_lt, pt_rb;

			pt_rb.x = static_cast<int>(window_sz.width);
			pt_rb.y = static_cast<int>(window_sz.height);

			nana::api::calc_screen_point(*this, pt_lt);
			nana::api::calc_screen_point(*this, pt_rb);

			int dx = 0, dy = 0;

			if (pt_lt.x < 0)
			{
				dx = -pt_lt.x;
				pt_lt.x = 0;
				pt_rb.x += dx;
			}
			else if (pt_rb.x > static_cast<int>(desktop_size.width))
			{
				dx = -(pt_rb.x - static_cast<int>(desktop_size.width));

				pt_rb.x = static_cast<int>(desktop_size.width);
				pt_lt.x += dx;
			}

			if (pt_lt.y < 0)
			{
				dy = -pt_lt.y;
				pt_lt.y = 0;
				pt_rb.y += dy;
			}
			else if (pt_rb.y > static_cast<int>(desktop_size.height))
			{
				dy = -(pt_rb.y - static_cast<int>(desktop_size.height));

				pt_rb.y = static_cast<int>(desktop_size.height);
				pt_lt.y += dy;
			}

			if (dy < 0)
				offset_ = dy;

			return nana::rectangle{ pt_lt, window_sz };
		}

		void _m_display()
		{
			//
			auto rect = _m_place();

			if (offset_)
			{
				auto pt = nana::api::window_position(host_form_);
				pt.y += offset_;

				nana::api::move_window(host_form_, pt);
			}

			auto pt = rect.position();
			nana::api::calc_window_point(host_, pt);


			rect.position(pt);

			this->move(rect);
			this->show();
		}

		void _m_resized()
		{
			_m_display();
			
		}
	private:
		window const host_;
		window const host_form_;
		keyboards::images const* images_;
		point origin_pt_;

		int offset_{ 0 };

		panel<true>* board_{ nullptr };


	};

	struct qwerty_parameters
	{
		std::vector<std::string> langs;
		virtual_keyboard::behaves behave{ virtual_keyboard::behaves::done };
		virtual_keyboard::modes mode{ virtual_keyboard::modes::letter_lower };
	};

	struct keyboard_host
	{
		bool qwerty{ true };
		std::unique_ptr<qwerty_parameters> qwerty_param; //Specific qwerty parameters

		nana::event_handle focus;
		nana::event_handle destroy;
		nana::event_handle msdown;
	};

	struct virtual_keyboard::implementation
	{
		qwerty_parameters qwerty;	//Default qwerty keyboard parameters

		std::map<window, keyboard_host> hosts;

		virtual_keyboard_window* win{ nullptr };

		keyboards::images images;
	};

	template<std::size_t Len>
	void make_keyboard_images(nana::paint::pixel_buffer& pxbuf, const std::uint16_t(&img)[Len])
	{
		pxbuf.open(120, 120);
		pxbuf.alpha_channel(true);
		pxbuf.make_transparent(0);

		auto p = pxbuf.raw_ptr(0);
		for (std::size_t i = 0; i < Len; i += 2)
		{
			auto val = static_cast<std::uint8_t>(img[i + 1]);
			for (std::size_t u = 0; u < img[i]; ++u)
			{
				p->value = 0;
				p->element.alpha_channel = val;
				++p;
			}
		}
	}

	virtual_keyboard::virtual_keyboard():
		impl_(new implementation)
	{
		impl_->qwerty.langs = {"en", "zh-CN", "ru"};

		make_keyboard_images(impl_->images.backspace, detail::keyboards::image_backspace_120x120);
		make_keyboard_images(impl_->images.earth, detail::keyboards::image_earth_120x120);
		make_keyboard_images(impl_->images.shift_lowercase, detail::keyboards::shift_lowercase_120x120);
		make_keyboard_images(impl_->images.shift_uppercase, detail::keyboards::shift_uppercase_120x120);
	}

	virtual_keyboard::~virtual_keyboard()
	{
		for (auto& host : impl_->hosts)
		{
			api::umake_event(host.second.focus);
			api::umake_event(host.second.destroy);
			api::umake_event(host.second.msdown);
		}
	}

	void virtual_keyboard::attach(window wd)
	{
		nana::internal_scope_guard lock;

		if (impl_->hosts.count(wd))
			//Exits if the window is already attached.
			return;

		auto& host = impl_->hosts[wd];

		auto& evts = api::events(wd);

		host.focus = evts.focus([this](const arg_focus& arg) {
			if (!arg.getting && impl_->win)
				impl_->win->close();
		});

		host.msdown = evts.mouse_down([this](const arg_mouse& arg) {
			if (api::focus_window() != arg.window_handle)
				return;

			auto text_area_opt = api::window_text_editor_rectangle(arg.window_handle, false);
			if (!text_area_opt || !api::window_text_editor_editable(arg.window_handle))
				return;

			auto pt = nana::api::cursor_position();
			api::calc_window_point(arg.window_handle, pt);

			if (text_area_opt.value().is_hit(pt))
			{
				if ((!impl_->win) || impl_->win->host() != arg.window_handle)
				{
					//popup keyboard

					impl_->win = &nana::form_loader<virtual_keyboard_window>{}(arg.window_handle, &(impl_->images));

					impl_->win->events().destroy([this](const arg_destroy&) {
						impl_->win = nullptr;
					});

					auto & host = impl_->hosts[arg.window_handle];

					if (host.qwerty)
					{
						qwerty_parameters* qp;
						if (host.qwerty_param)
							qp = host.qwerty_param.get();
						else
							qp = &impl_->qwerty;

						impl_->win->qwerty(qp->langs, qp->behave, qp->mode);
					}
					else
						impl_->win->numeric();
				}
			}
		});

		host.destroy = evts.destroy([this](const arg_destroy& arg){
			impl_->hosts.erase(arg.window_handle);
			if (impl_->win)
				impl_->win->close();
		});
	}

	bool virtual_keyboard::qwerty(window wd, std::vector<std::string> langs, behaves behave, modes mode)
	{
		auto i = impl_->hosts.find(wd);
		if (i == impl_->hosts.cend())
			return false;

		i->second.qwerty = true;
		if (!i->second.qwerty_param)
			i->second.qwerty_param.reset(new qwerty_parameters);

		i->second.qwerty_param->langs.swap(langs);
		i->second.qwerty_param->behave = behave;
		i->second.qwerty_param->mode = mode;
		return true;
	}

	bool virtual_keyboard::numeric(window wd)
	{
		auto i = impl_->hosts.find(wd);
		if (i == impl_->hosts.cend())
			return false;

		i->second.qwerty = false;
		i->second.qwerty_param.reset();
		return true;
	}
}